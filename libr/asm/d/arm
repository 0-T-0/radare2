bic=logical bit clear
b=branches the program counter to dst (pc aka r15)
eor=logical exclusive OR (XOR)
oor=logical inclusive OR
sub=substract
rsb=reverse substract
add=add
adc=add with carry
sbc=substract with carry
tst=test
teq=test equivalence
cmn=compare negated
cmp=compare
bl=branches and link, similar to call in i386, set lr(r14) = pc, changes pc (r15) )
bx=branches and exchanges cpu mode to 16 bits (thumb mode)
bxj=branches and exchanges cpu mode to Jazzele (jumps to a bytecode vector)
beq=branches if equal (see 'b')
bne=branches if not equal (see 'b')
cmp=compares two registers
str=store register intro memory
ldr=load from memory to register
ldf=armfpu: load float value pointed by reg+(offset): ldf f0, [r0,#off]
stf=armfpu: store float value pointed by reg+(offset): ldf [r0,#off]
flt=armfpu: convert int to float: flt 
wfs=armfpu: write fp status register. wfs r0
stc=store from coprocessor to memory
ldc=load from memory to coprocessor
cdp=coprocessor data operations
mcr=move to coprocessor from ARM register
mcrr=move to coprocessor from two ARM register
stc=store coprocessor register
ldmib=increment before
ldmdb=decrement before
ldmia=incrememnt after
ldmda=decrement after
srs=store return state
rfe=return from exception (loads pc+cpsr)
cps=change processor state
vsri=vector shift right and insert
vadd=vector add
ubfx=unsigned bit field extract
sbfx=signed bit field extract
uxtab16=zero extend bytes to halfwords add halfwords
uxtab=zero extend byte to word, add
rsc=reverse substract with carry
svc=supervisor call
